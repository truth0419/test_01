<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>ìŠ¤ë„¤ì´í¬ ê²Œì„ (HTML/JS)</title>
  <style>
    :root {
      --bg: #111827; --panel: #1f2937; --snake: #34d399;
      --snake-head: #10b981; --food: #f43f5e; --text: #e5e7eb; --accent: #60a5fa;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0; background: radial-gradient(1200px 600px at 50% -100px, #0b1220, var(--bg));
      color: var(--text); font-family: system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans KR", Arial, sans-serif;
      display: grid; min-height: 100svh; place-items: center; padding: 16px;
    }
    .wrap { width: min(92vw, 720px); }
    header { display: flex; align-items: center; justify-content: space-between; gap: 12px; margin-bottom: 12px; }
    .title { font-weight: 700; letter-spacing: 0.2px; }
    .panel {
      background: linear-gradient(180deg, #111827, var(--panel));
      border: 1px solid #374151; border-radius: 12px; padding: 10px 12px;
      display: flex; align-items: center; gap: 12px;
      box-shadow: 0 10px 20px rgba(0,0,0,.25), inset 0 1px 0 rgba(255,255,255,.03);
    }
    .row { display: flex; align-items: center; gap: 12px; flex-wrap: wrap; }
    .stat { font-variant-numeric: tabular-nums; }
    .btn, select {
      background: #0b1220; color: var(--text); border: 1px solid #334155; border-radius: 10px;
      padding: 10px 14px; font-weight: 600; cursor: pointer;
      transition: transform .06s ease, background .2s ease, border .2s ease;
    }
    .btn:hover, select:hover { background: #111a2b; border-color: #3b82f6; }
    .btn:active { transform: translateY(1px); }
    .board {
      margin-top: 12px; background: #0b1220; border: 1px solid #334155; border-radius: 12px;
      aspect-ratio: 1 / 1; width: 100%; display: grid; place-items: center; overflow: hidden; position: relative;
    }
    canvas { width: 100%; height: 100%; image-rendering: pixelated; }
    .overlay {
      position: absolute; inset: 0; display: grid; place-items: center; text-align: center;
      background: linear-gradient(180deg, rgba(2,6,23,.3), rgba(2,6,23,.55));
      backdrop-filter: blur(2px); opacity: 0; pointer-events: none; transition: opacity .2s ease; padding: 20px;
    }
    .overlay.show { opacity: 1; pointer-events: auto; }
    .overlay .card {
      background: #0b1220; border: 1px solid #334155; border-radius: 14px; padding: 18px;
      max-width: 440px; width: min(90%, 440px); box-shadow: 0 20px 40px rgba(0,0,0,.35);
    }
    .grid { display: grid; gap: 10px; grid-template-columns: repeat(2, minmax(0, 1fr)); }
    .grid .btn { width: 100%; }
    .hint { color: #9ca3af; font-size: 12px; }
    .chip { padding: 4px 8px; background: #0f172a; border: 1px solid #334155; border-radius: 999px; font-size: 12px; color: #cbd5e1; }
  </style>
</head>
<body>
  <div class="wrap">
    <header class="panel">
      <div class="row">
        <div class="title">ğŸŸ¢ ìŠ¤ë„¤ì´í¬</div>
        <span class="chip">í‚¤ë³´ë“œ ë°©í–¥í‚¤</span>
      </div>
      <div class="row">
        <div class="stat">ì ìˆ˜: <strong id="score">0</strong></div>
        <div class="stat">ìµœê³ : <strong id="best">0</strong></div>
        <select id="wallMode" title="ë²½ ëª¨ë“œ">
          <option value="solid" selected>ë²½ ì¶©ëŒ</option>
          <option value="wrap">ë²½ í†µê³¼</option>
        </select>
        <button id="resetBtn" class="btn">ë‹¤ì‹œ ì‹œì‘</button>
      </div>
    </header>

    <div class="board">
      <canvas id="game" width="400" height="400" aria-label="ìŠ¤ë„¤ì´í¬ ê²Œì„ ë³´ë“œ"></canvas>
      <div id="overlay" class="overlay">
        <div class="card">
          <h3 id="stateTitle" style="margin: 0 0 8px">ì‹œì‘í•˜ë ¤ë©´ â–¶ ì‹œì‘</h3>
          <p id="stateDesc" class="hint" style="margin: 0 0 14px">ë°©í–¥í‚¤ë¡œ ë±€ì„ ì›€ì§ì—¬ ë¨¹ì´ë¥¼ ë“œì„¸ìš”.</p>
          <div class="grid">
            <button id="startBtn" class="btn">â–¶ ì‹œì‘</button>
            <button id="resumeBtn" class="btn">â¯ ê³„ì†</button>
            <button id="restartBtn" class="btn">â†º ìƒˆ ê²Œì„</button>
            <button id="slowBtn" class="btn">ğŸ¢ ëŠë¦¬ê²Œ</button>
          </div>
        </div>
      </div>
    </div>

    <p class="hint" style="margin-top:10px">
      íŒ: <kbd>Space</kbd> ì¼ì‹œì •ì§€/ê³„ì† &nbsp;|&nbsp; <kbd>R</kbd> ì¬ì‹œì‘ &nbsp;|&nbsp; <kbd>W</kbd> ë²½ ëª¨ë“œ ì „í™˜
    </p>
  </div>

  <script>
    // ===== ê²Œì„ ì„¤ì • =====
    const CELL = 20;          // í•œ ì¹¸ í”½ì…€ (20px â†’ 20x20 ê·¸ë¦¬ë“œ)
    const SIZE = 400;         // ìº”ë²„ìŠ¤ í¬ê¸°
    const GRID = SIZE / CELL; // 20
    const START_LEN = 4;
    const START_SPEED = 130;  // ë‚®ì„ìˆ˜ë¡ ë¹ ë¦„(ms)
    const SPEED_STEP = 3;     // ë¨¹ì´ ë¨¹ì„ ë•Œ ì†ë„ ì¦ê°€(ê°ì†Œ)
    const MIN_SPEED = 60;

    // ===== ìƒíƒœ =====
    let snake, dir, nextDir, food, score, best, speed, timer, running = false, paused = true;
    let wallMode = 'solid'; // 'solid' | 'wrap'

    // ===== ì—˜ë¦¬ë¨¼íŠ¸ =====
    const cvs = document.getElementById('game');
    const ctx = cvs.getContext('2d');
    const scoreEl = document.getElementById('score');
    const bestEl = document.getElementById('best');
    const overlay = document.getElementById('overlay');
    const stateTitle = document.getElementById('stateTitle');
    const stateDesc = document.getElementById('stateDesc');
    const startBtn = document.getElementById('startBtn');
    const resumeBtn = document.getElementById('resumeBtn');
    const restartBtn = document.getElementById('restartBtn');
    const slowBtn = document.getElementById('slowBtn');
    const wallSel = document.getElementById('wallMode');
    const resetBtn = document.getElementById('resetBtn');

    // ===== ìœ í‹¸ =====
    const rng = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;

    function loadBest() {
      try { return Number(localStorage.getItem('snake_best') || 0); } catch { return 0; }
    }
    function saveBest(val) {
      try { localStorage.setItem('snake_best', String(val)); } catch {}
    }

    function init() {
      snake = [];
      const startX = Math.floor(GRID / 2);
      const startY = Math.floor(GRID / 2);

      // ğŸ”§ ë²„ê·¸ ìˆ˜ì •: pushë¡œ ê¼¬ë¦¬â†’ë¨¸ë¦¬ ìˆœì„œë¡œ ë°°ì¹˜ (ë¨¸ë¦¬ê°€ ì˜¤ë¥¸ìª½ ë)
      // ì˜ˆ: [ (startX-3), (startX-2), (startX-1), (startX=ë¨¸ë¦¬) ]
      for (let i = START_LEN - 1; i >= 0; i--) {
        snake.push({ x: startX - i, y: startY });
      }

      dir = { x: 1, y: 0 };
      nextDir = { x: 1, y: 0 };
      score = 0; speed = START_SPEED;
      best = loadBest(); bestEl.textContent = best;

      placeFood();
      draw();
      updateScore();
      showOverlay(true, 'ì‹œì‘í•˜ë ¤ë©´ â–¶ ì‹œì‘', 'ë°©í–¥í‚¤ë¡œ ë±€ì„ ì›€ì§ì—¬ ë¨¹ì´ë¥¼ ë“œì„¸ìš”.');
      paused = true; running = false;
    }

    function placeFood() {
      while (true) {
        const f = { x: rng(0, GRID - 1), y: rng(0, GRID - 1) };
        if (!snake.some(s => s.x === f.x && s.y === f.y)) { food = f; break; }
      }
    }

    function updateScore() {
      scoreEl.textContent = score;
      if (score > best) { best = score; bestEl.textContent = best; saveBest(best); }
    }

    function showOverlay(show, title = '', desc = '') {
      overlay.classList.toggle('show', show);
      if (title) stateTitle.textContent = title;
      if (desc !== undefined) stateDesc.textContent = desc;
      resumeBtn.style.display = paused && running ? 'inline-block' : 'none';
      startBtn.style.display = (!running) ? 'inline-block' : 'none';
    }

    function gameOver() {
      running = false; paused = true;
      showOverlay(true, 'ê²Œì„ ì¢…ë£Œ ğŸ’¥', `ì ìˆ˜: ${score}  |  ìµœê³ : ${best}`);
      clearTimeout(timer);
    }

    function step() {
      // ë°©í–¥ ì—…ë°ì´íŠ¸ (í‹±ë‹¹ 1íšŒ)
      dir = nextDir;

      const head = { ...snake[snake.length - 1] }; // í˜„ì¬ ë¨¸ë¦¬(ë§ˆì§€ë§‰ ìš”ì†Œ) ê¸°ì¤€ìœ¼ë¡œ ì´ë™
      head.x += dir.x; head.y += dir.y;

      // ë²½ ì²˜ë¦¬
      if (wallMode === 'wrap') {
        head.x = (head.x + GRID) % GRID;
        head.y = (head.y + GRID) % GRID;
      } else {
        if (head.x < 0 || head.x >= GRID || head.y < 0 || head.y >= GRID) return gameOver();
      }

      // ìê¸°ì¶©ëŒ ê²€ì‚¬
      if (snake.some(s => s.x === head.x && s.y === head.y)) return gameOver();

      // ì´ë™: ë¨¸ë¦¬ë¥¼ ë’¤(ë)ì— ë¶™ì´ê³  ê¼¬ë¦¬ ì œê±°
      snake.push(head);

      // ë¨¹ì´
      if (head.x === food.x && head.y === food.y) {
        score++; updateScore(); placeFood();
        speed = Math.max(MIN_SPEED, speed - SPEED_STEP);
      } else {
        snake.shift(); // ê¼¬ë¦¬ ì œê±°
      }

      draw();
      if (!paused) timer = setTimeout(step, speed);
    }

    function drawCell(x, y, color) {
      ctx.fillStyle = color;
      ctx.fillRect(x * CELL, y * CELL, CELL, CELL);
    }

    function drawGridBg() {
      for (let y = 0; y < GRID; y++) {
        for (let x = 0; x < GRID; x++) {
          ctx.fillStyle = (x + y) % 2 === 0 ? '#0c1425' : '#0a1120';
          ctx.fillRect(x * CELL, y * CELL, CELL, CELL);
        }
      }
    }

    function draw() {
      ctx.clearRect(0, 0, SIZE, SIZE);
      drawGridBg();

      // ë¨¹ì´
      ctx.fillStyle = getFoodGradient(food.x, food.y);
      const padF = 2;
      ctx.beginPath();
      ctx.roundRect(food.x * CELL + padF, food.y * CELL + padF, CELL - padF*2, CELL - padF*2, 4);
      ctx.fill();

      // ë±€ (ê¼¬ë¦¬â†’ë¨¸ë¦¬ ìˆœì„œë¡œ ê·¸ë¦¬ë˜, ë¨¸ë¦¬ ê°•ì¡°)
      snake.forEach((seg, i) => {
        const isHead = (i === snake.length - 1);
        const pad = isHead ? 2 : 3;
        ctx.fillStyle = isHead ? getHeadGradient(seg.x, seg.y) : getBodyGradient(seg.x, seg.y);
        ctx.beginPath();
        ctx.roundRect(seg.x * CELL + pad, seg.y * CELL + pad, CELL - pad*2, CELL - pad*2, isHead ? 6 : 5);
        ctx.fill();
      });
    }

    // ê·¸ë¼ë””ì–¸íŠ¸
    function getBodyGradient(x, y) {
      const g = ctx.createLinearGradient(x*CELL, y*CELL, x*CELL + CELL, y*CELL + CELL);
      g.addColorStop(0, '#34d399'); g.addColorStop(1, '#059669');
      return g;
    }
    function getHeadGradient(x, y) {
      const g = ctx.createLinearGradient(x*CELL, y*CELL, x*CELL + CELL, y*CELL + CELL);
      g.addColorStop(0, '#10b981'); g.addColorStop(1, '#0ea5e9');
      return g;
    }
    function getFoodGradient(x, y) {
      const g = ctx.createRadialGradient(x*CELL + CELL/2, y*CELL + CELL/2, 2, x*CELL + CELL/2, y*CELL + CELL/2, CELL/2);
      g.addColorStop(0, '#f43f5e'); g.addColorStop(1, '#be123c');
      return g;
    }

    // ===== ì…ë ¥: í‚¤ë³´ë“œ ë°©í–¥í‚¤ë§Œ ì§€ì› =====
    const dirs = {
      ArrowUp:    { x: 0, y: -1, opp: 'ArrowDown'  },
      ArrowDown:  { x: 0, y:  1, opp: 'ArrowUp'    },
      ArrowLeft:  { x: -1, y: 0, opp: 'ArrowRight' },
      ArrowRight: { x:  1, y: 0, opp: 'ArrowLeft'  }
    };

    function setDirection(key) {
      const d = dirs[key];
      if (!d) return;
      // í˜„ì¬ ì§„í–‰ë°©í–¥ì˜ ë°˜ëŒ€ë¡œëŠ” ê³§ë°”ë¡œ ëª» ëŒì•„ê°
      const curKey = Object.keys(dirs).find(k => dirs[k].x === dir.x && dirs[k].y === dir.y);
      if (curKey && d.opp === curKey) return;
      nextDir = { x: d.x, y: d.y };
    }

    window.addEventListener('keydown', (e) => {
      if (dirs[e.key]) { e.preventDefault(); setDirection(e.key); if (!running) start(); }
      if (e.code === 'Space') { e.preventDefault(); togglePause(); }
      if (e.key.toLowerCase() === 'r') restart();
      if (e.key.toLowerCase() === 'w') toggleWallMode();
    }, { passive: false });

    // ===== ì œì–´ =====
    function start() {
      if (running && !paused) return;
      paused = false; running = true;
      showOverlay(false);
      clearTimeout(timer);
      timer = setTimeout(step, speed);
    }

    function togglePause() {
      if (!running) return;
      paused = !paused;
      if (paused) {
        clearTimeout(timer);
        showOverlay(true, 'ì¼ì‹œì •ì§€ â¸', 'ê³„ì†í•˜ë ¤ë©´ â¯ ê³„ì† ì„ ëˆ„ë¥´ì„¸ìš”. (Space)');
      } else {
        showOverlay(false);
        timer = setTimeout(step, speed);
      }
    }

    function restart(slower = false) {
      init();
      if (slower) speed = 180;
      start();
    }

    function toggleWallMode() {
      wallMode = (wallMode === 'solid') ? 'wrap' : 'solid';
      wallSel.value = wallMode;
    }

    // UI ë²„íŠ¼
    startBtn.addEventListener('click', start);
    resumeBtn.addEventListener('click', togglePause);
    restartBtn.addEventListener('click', () => restart(false));
    slowBtn.addEventListener('click', () => restart(true));
    wallSel.addEventListener('change', (e) => wallMode = e.target.value);
    resetBtn.addEventListener('click', () => restart(false));

    // ì´ˆê¸°í™”
    init();

    // ìº”ë²„ìŠ¤ roundRect í´ë¦¬í•„(êµ¬ë²„ì „ ë¸Œë¼ìš°ì €)
    if (!CanvasRenderingContext2D.prototype.roundRect) {
      CanvasRenderingContext2D.prototype.roundRect = function(x, y, w, h, r) {
        r = Math.min(r, w/2, h/2);
        this.beginPath();
        this.moveTo(x + r, y);
        this.arcTo(x + w, y, x + w, y + h, r);
        this.arcTo(x + w, y + h, x, y + h, r);
        this.arcTo(x, y + h, x, y, r);
        this.arcTo(x, y, x + w, y, r);
        this.closePath();
        return this;
      }
    }
  </script>
</body>
</html>
